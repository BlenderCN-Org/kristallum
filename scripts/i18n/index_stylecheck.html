<html lang="en">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<head>
<script type="text/javascript" src="head.load.min.js"></script>
<style>

body {
	text-align: center; font-family: Helvetica, Arial, sans-serif; font-size: 13px;
	color: #000;
}
.inv {color: #fff; background-color: gray}
* { color: #555; text-shadow: #fff 0 1px 0px; }
h3 { color: #333; font-size: 16px; margin-bottom: 0; padding-bottom: 0; }

</style>
<script>
var _sameworda = "_sameworda";
var _minen4sameword = 4;
var rulezz = [
	{name:"many",countIf:[" поня", " ладно"],
		onlyIf:["**", "<=", "=>"], resetIf:["scene", "-!", "-o"],okIfMinDistanceInLines:15},
	{name:"many",countIf:["хорошо", "отлично"],
		onlyIf:["**", "<=", "=>"], resetIf:["scene", "-!", "-o"],okIfMinDistanceInLines:15},

	{name:"same",countIf:[_sameworda], // dbg: true,
		onlyIf:["**", "<=", "=>"], resetIf:["scene", "-!", "-o"],okIfMinDistanceInLines:4},
	//{name:"same_l",countIf:[_sameworda],
	//	onlyIf:["<="], resetIf:["scene", "-!", "-o"],okIfMinDistanceInLines:4},
	//{name:"same_r",countIf:[_sameworda],
	//	onlyIf:["=>"], resetIf:["scene", "-!", "-o"],okIfMinDistanceInLines:4},
	//{name:"same_c",countIf:[_sameworda],
	//	onlyIf:["**"], resetIf:["scene", "-!", "-o"],okIfMinDistanceInLines:4},

	{name:"leng_adlg",countIf:["=>", "<="],
		onlyIf:["**", "<=", "=>"], resetIf:["**", "scene","-!", "-o"],okIfMaxRepeat:20},
	{name:"leng_rdlg",countIf:["=>"],
		onlyIf:["**", "<=", "=>"], resetIf:["**", "<=", "scene","-!", "-o"],okIfMaxRepeat:7},
	{name:"leng_ldlg",countIf:["<="],
		onlyIf:["**", "<=", "=>"], resetIf:["**", "=>", "scene","-!", "-o"],okIfMaxRepeat:7}
];

var single_manis = [" я ", " и ", " нет ", " да ", " для ", " это ", " эти ", " вот ",
	" мне ", " он ", " она ", " они ", " оно ", " его ", " ее ", " их ", " ней ",
	" что ", " кто ", " про ", " где ", " уже ", " еще ",
	" все ", " все жe ", " как ", " так ", " там ", " тут ", " был "
]
for(var i=0;i<single_manis.length;i++){
	rulezz.push(
	{name:"many",countIf:[single_manis[i]],
		onlyIf:["**", "<=", "=>"], resetIf:["scene", "-!", "-o"],okIfMinDistanceInLines:1}
	);
}


var extendedWhitespaceCharsList = [".",",","?","!",":",";","'","  ","  ","  "];// "<",">" used in countIf. "-" in words
var extendedIgnoredCharsList = ["\t","{","}","(",")","[","]","\""];// "<",">" used in countIf
function normalizeLinr(raw_text) {
	for(var i=0;i<extendedIgnoredCharsList.length;i++){
		//raw_text = raw_text.replace(extendedIgnoredCharsList[i],"");
		raw_text = raw_text.split(extendedIgnoredCharsList[i]).join("");
	}
	if(raw_text.length == 0){
		return raw_text;
	}
	for(var i=0;i<extendedWhitespaceCharsList.length;i++){
		//raw_text = raw_text.replace(extendedWhitespaceCharsList[i]," ");
		raw_text = raw_text.split(extendedWhitespaceCharsList[i]).join(" ");
	}
	raw_text = " "+raw_text.toLowerCase()+" ";
	return raw_text;
}

function normalizeWodrd(normalized) {
	var words = normalized.split(" ");
	var res = [];
	for(var i=0;i<words.length;i++){
		var str = words[i];
		if(!isWordOk4samecheck(str)){
			continue;
		}
		if(str.length > 7){
			str = str.substr(0,7);
		}
		if(str.length > 0 && res.indexOf(str) < 0){
			res.push(str);
		}
	}
	//console.log("normalizeWodrd: ",res);
	return res;
}

function isWordOk4samecheck(str) {
	if(str == null || str.length < _minen4sameword){
		return false;
	}
	if(!(/[а-яА-ЯЁё]/.test(str))){
		//console.log("isWordOk4samecheck: NOT ok "+str);
		return false;
	}
	//console.log("isWordOk4samecheck: ok "+str);
	return true;
}

function checkStyle() {
	var raw_text = $('#part_jsta').val();
	var res = "";
	var raw_lines = raw_text.split("\n");
	for(var j=0;j<rulezz.length;j++){
		rulezz[j].state = {cntPresent: 0};
		rulezz[j].history = [];
	}
	for(var i=0;i<raw_lines.length;i++){
		var original = raw_lines[i];
		var normalized = normalizeLinr(original);
		if(normalized.length <= 1){
			continue;
		}
		var normalized_byword = normalizeWodrd(normalized);
		normalized_byword.unshift(normalized + "_at_line"+(i+1)+"_");
		var failedRules = [];
		//console.log("DBG:" + "-normalized: [["+normalized+"]]");
		for(var j=0;j < rulezz.length;j++){
			var rule = rulezz[j];
			var isIgnored = 0;
			//var isIgnoredReason = "";
			if(rule.resetIf != null){
				for(var k=0;k<rule.resetIf.length;k++){
					if(original.indexOf(rule.resetIf[k]) >= 0){
						rule.history = [];
						rule.state.cntPresent = 0;
						//isIgnoredReason = rule.resetIf[k];
						isIgnored = 2;
						break;
					}
				}
			}
			if(rule.ignoreIf != null){
				for(var k=0;k<rule.ignoreIf.length;k++){
					if(original.indexOf(rule.ignoreIf[k]) >= 0){
						//isIgnoredReason = rule.ignoreIf[k];
						isIgnored = 1;
						break;
					}
				}
			}
			if(rule.onlyIf != null){
				var isAnyPresent = false;
				for(var k=0;k<rule.onlyIf.length;k++){
					if(original.indexOf(rule.onlyIf[k]) >= 0){
						isAnyPresent = true;
					}
				}
				if(!isAnyPresent){
					//isIgnoredReason = rule.onlyIf[k];
					isIgnored = 3;
				}
			}
			if(isIgnored > 0){
				if(isIgnored == 1 || isIgnored == 2){
					// STILL adding to history - samewording on '-!**' and resetters should work
					rule.history.push(normalized_byword);
				}
				//console.log("DBG: ignored " + isIgnored+", " +rule.name, normalized_byword);
				continue;
			}
			var isPresent = false;
			for(var k=0;k < rule.countIf.length; k++){
				if(normalized.indexOf(rule.countIf[k]) >= 0){
					isPresent = true;
				}
			}
			if(rule.okIfMinDistanceInLines != null){
				var isLineOk = true;
				var deepness = rule.okIfMinDistanceInLines;
				for(var k=0;k < rule.countIf.length; k++){
					if(rule.countIf[k] == _sameworda){
						for(var k2=1; k2 < normalized_byword.length; k2++){
							for(var k3=rule.history.length-1; k3 >= 0 && k3>=rule.history.length-deepness; k3--){
								if(rule.history[k3].indexOf(normalized_byword[k2]) >= 0){
									var err = "'" + normalized_byword[k2] + "' in {"+rule.history[k3][0]+"}, min "+deepness+"("+(rule.history.length-k3)+")";
									//k2 = 9999999;
									//k = 999999;
									failedRules.push(rule.name + " " +err);
									//console.log("DBG:" + rule.name, normalized_byword);
									break;
								}
							}
						}
					}else if(isPresent){
						for(var k3=rule.history.length-1; k3>=0 && k3>=rule.history.length-deepness; k3--){
							if(rule.history[k3][0].indexOf(rule.countIf[k]) >= 0){// normalized
								var err = "'" + rule.countIf[k] + "' in {"+rule.history[k3][0]+"}, min "+deepness+"("+(rule.history.length-k3)+")";
								failedRules.push(rule.name + " " +err);
								//k = 999999;
								//console.log("DBG:" + rule.name, normalized_byword);
								break;
							}
						}
					}
				}
			}
			if(rule.okIfMaxRepeat != null){
				if(isPresent){
					rule.state.cntPresent = rule.state.cntPresent + 1;
					if(rule.state.cntPresent > rule.okIfMaxRepeat){
						failedRules.push(rule.name + " max "+rule.okIfMaxRepeat+"("+rule.state.cntPresent+")");
						//console.log("DBG:" + rule.name, normalized_byword);
					}
				}
				if(!isPresent){
					rule.state.cntPresent = 0;
				}
			}
			if(rule.dbg == true){
				console.log("DBG:" + rule.name, [normalized_byword, failedRules, rule]);
			}
			// adding to history
			rule.history.push(normalized_byword);
		}
		if(res.length > 0){
			res += "\n";
		}
		res += original;
		if(failedRules.length > 0){
			for(var k=0;k<failedRules.length;k++){
				res += "\n^--------- style errors: "+failedRules[k]+" ---------";
			}
			res += "\n";
		}
	}
	$("#part_outputa").val(res);
}

function initClient() {
	$(document).ready(function(e){
		$("#part_outputa").dblclick(function() {
			var t = $("#part_outputa")[0];
			var tv = t.value;
			var lastlineCharPos = t.selectionStart;
			while(lastlineCharPos < tv.length && tv.charAt(lastlineCharPos) != "\n"){
				lastlineCharPos++;
			}
			var lines = tv.substr(0, lastlineCharPos).split("\n");
    		var line = lines[lines.length-1];
			var testRE = line.match("_at_line(.*)_");
			//console.log("DBG:" + line, testRE);
			if(testRE && testRE[1]){
				var jump2line = parseInt(testRE[1]);
				var t2 = $("#part_jsta")[0];
				var tv2 = t2.value;
				var tv2lines = tv2.split("\n");
			    // calculate start/end
			    var startPos = 0;
			    for(var x = 0; x < tv2lines.length; x++) {
			        if(x == jump2line-1) {
						t2.focus();
						//t2.selectionStart = startPos;
				        //t2.selectionEnd = startPos+(tv2lines[x].length)-1;
						t2.setSelectionRange(startPos,startPos+(tv2lines[x].length)-1);
						var lineHeight = parseInt($("#part_jsta").css('line-height'));
						$("#part_jsta").scrollTop((jump2line-3) * lineHeight);
			            break;
			        }
			        startPos += (tv2lines[x].length+1);
			    }
			}
		});
	});
}
head.js("jquery-1.7.1.min.js","jquery.json-2.2.min.js",initClient);
</script>
</head>
<body scroll="no" class="bg">
<center>
<div id="part_js" style="width:100%;height:280px">
<textarea id="part_jsta" style="width:100%;height:100%;font-size:20px;line-height:24px;">
</textarea>
</div>
<input type="button" value="Check Style" onClick="checkStyle();" style="-webkit-appearance:none;margin:5px 5px 5px 5px;width:200px;height:40px;font-size:20px;">
<div id="part_output" style="width:100%;height:600px;">
<textarea id="part_outputa" style="width:100%;height:100%;font-size:15px;">
</textarea>
</div>
</center>
</body>
</html>
