#define WIDECOVER_MUL 1000.0
#define VERT_CACHE_MAX 15

//float triangleArea(point p1, point p2, point p3)
//{
//	point s1 = p2-p1;
//	point s2 = p3-p1;
//	float ar = 0.5*length(cross(s1,s2));
//	return ar;
//}

void make_orthonormals(vector N, output vector a, output vector b)
{
	if(N[0] != N[1] || N[0] != N[2]) a = cross(vector(1, 1, 1), N);
	else a = cross(vector(-1, 1, 1), N);
	a = normalize(a);
	b = cross(N, a);
}


shader detEdge(
	float iterations = 8.0,
	point distance_XY = point(0.0,0.1,0.0),
	point camera_Shift = point(0.0,0.0,0.0),
	point opt_SF_FL = point(0.01,400.0,0.0),
	point opt_BS_BH = point(0.01,0.15,0.0),
	point stopI_DST_NRM = point(0.1,0.5,0.0),
	point stopO_DST_NRM = point(0.01,0.1,0.0),

	string colVC_Name = "",
	color colVC_Value = color(0,0,0),
	point stop_iVC_oVC = point(10.0,10.0,10.0),
	point in_pos = point(0,0,0),

	output float Alpha = 0.0,
	output float Holdout = 0.0,
	output point Averages = point(0,0,0)
)
{
	if(length(distance_XY) < 0.0001 || iterations < 1.0){
		// Fast exit for no-need-to-test cases
		return;
	}
	point pThis = isconnected(in_pos)?in_pos:P;
	point nInc = I;
	point nThis = N;
	point pCamWrlIni = transform("camera", "common", camera_Shift);
	point pDirIni = normalize(pThis - pCamWrlIni);
	float camDistBase = length(pThis - pCamWrlIni);

	float sameFaceIO = opt_SF_FL[0];
	float antiFlatArea = opt_SF_FL[1]*(1.0-dot(N,I));
	if(antiFlatArea > 0.0001 && area(P) > antiFlatArea*WIDECOVER_MUL){
		Holdout = 999;
		return;
	}
	float camDiffSkip = opt_BS_BH[0];
	float camDiffHoldout = opt_BS_BH[1];

	float isvcnameset = strlen(colVC_Name);
	point triagVertx[3];
	getattribute("geom:trianglevertices",triagVertx);
	point vertCache[VERT_CACHE_MAX];
	for(int i = 0;i<VERT_CACHE_MAX;i++){
		vertCache[i] = triagVertx[0];
	}
	vertCache[1] = triagVertx[1];
	vertCache[2] = triagVertx[2];
	int vertCacheIdx = 2;

	point rp1 = N;
	point rp2 = N;
	make_orthonormals(I, rp1, rp2);
	float hstep = 1.0/iterations;
	float edgeFoundAt = -1;
	point pThisLast = pThis;
	point nThisLast = nThis;
	for(float ii = hstep; ii <= 1; ii = ii+hstep){
		point pCamWrl = pCamWrlIni+distance_XY[0]*rp1*ii+distance_XY[1]*rp2*ii;
		point pHit;
		int isHit = trace(pCamWrl, pDirIni);
		if(isHit < 1){
			edgeFoundAt = ii;
			break;
		}
		point nHit = nThis;
		getmessage("trace","P",pHit);
		getmessage("trace","N",nHit);
		float camDist = length(pCamWrlIni-pHit);
		float posDist = camDistBase-camDist;
		point hitVertx[3];
		getmessage("trace","geom:trianglevertices",hitVertx);
		float isSameFaceTriangle = 0;
		for(int i = 0;i<VERT_CACHE_MAX;i++){
			if(length(vertCache[i] - hitVertx[0]) < sameFaceIO
				|| length(vertCache[i] - hitVertx[1]) < sameFaceIO
				|| length(vertCache[i] - hitVertx[2]) < sameFaceIO){
				isSameFaceTriangle = 1;
				break;
			}
		}
		if(isSameFaceTriangle == 0){
			if(posDist >= camDiffSkip)
			{
				if(posDist >= camDiffHoldout){
					// Point completely non-valid, masking geometry present
					Holdout = 1;
				}
				return;
			}
			vertCache[vertCacheIdx] = hitVertx[0];
			vertCacheIdx = (vertCacheIdx+1)%VERT_CACHE_MAX;
			vertCache[vertCacheIdx] = hitVertx[1];
			vertCacheIdx = (vertCacheIdx+1)%VERT_CACHE_MAX;
			vertCache[vertCacheIdx] = hitVertx[2];
			vertCacheIdx = (vertCacheIdx+1)%VERT_CACHE_MAX;
		}
		float hitDist = length(pThisLast-pHit);
		float nrmDist = fabs(acos(dot(nHit,I))-acos(dot(nThisLast,I)))/M_PI;
		float nrmDist2 = (acos(dot(nHit,nThis)))/M_PI;
		float vcDist = 0;
		color hitVC = colVC_Value;
		if(isvcnameset > 0){
			getmessage("trace",colVC_Name,hitVC);
			if(length(hitVC) < length(colVC_Value)){
				vcDist = length(hitVC-colVC_Value);
			}
		}
		Averages = Averages+point(isSameFaceTriangle, hitDist, nrmDist2);
		if(isSameFaceTriangle < 1.0){
			if(hitDist >= stopO_DST_NRM[0]
				|| (nrmDist > stopO_DST_NRM[1] && nrmDist2 > stopO_DST_NRM[2])
				|| vcDist > stop_iVC_oVC[1]){
				edgeFoundAt = ii;
				break;
			}
		}else{
			if(hitDist >= stopI_DST_NRM[0]
				|| (nrmDist > stopI_DST_NRM[1] && nrmDist2 > stopI_DST_NRM[2])
				|| vcDist > stop_iVC_oVC[0]){
				edgeFoundAt = ii;
				break;
			}
		}
		pThisLast = pHit;
		nThisLast = nHit;
	}
	Averages = Averages/iterations;
	if(edgeFoundAt >= 0){
		Alpha = 1.0+hstep-edgeFoundAt;
	}
}
