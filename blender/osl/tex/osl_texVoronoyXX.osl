/* Voronoi Distances */

/* For some reason most of the distance metrics were commented out in the */
/* original node_texture.h I just restored that (varkenvarken) */

float voronoi_distance(int distance_metric, vector d, float e)
{
	if (distance_metric == 0)//"Distance Squared"
		return dot(d, d);
	if (distance_metric == 1)//"Actual Distance"
		return length(d);
	if (distance_metric == 2)//"Manhattan"
		return (fabs(d[0]) + fabs(d[1]) + fabs(d[2]));
	if (distance_metric == 3)//"Chebychev"
		return max(fabs(d[0]), max(fabs(d[1]), fabs(d[2])));
	if (distance_metric == 4)//"Minkovsky 1/2"
		return sqrt( sqrt(fabs(d[0])) + sqrt(fabs(d[1])) + sqrt(fabs(d[2])));
	if (distance_metric == 5)//"Minkovsky 4"
		return sqrt(sqrt(dot(d * d, d * d)));
	if (distance_metric == 6)//"Minkovsky"
		return pow(pow(fabs(d[0]), e) + pow(fabs(d[1]), e) + pow(fabs(d[2]), e), 1.0 / e);
	if (distance_metric == 7)//"Sine"
		return length(d) + (1 + sin(e * length(d)))/2;
	return 0.0;
}

/* Voronoi / Worley like */
color cellnoise_color(point p)
{
	float r = cellnoise(p);
	float g = cellnoise(point(p[1], p[0], p[2]));
	float b = cellnoise(point(p[1], p[2], p[0]));
	return color(r, g, b);
}

void voronoi(point p, int distance_metric, float e, float da[4], point pa[4], point mask_center, float mask_dist, point mask_scale)
{
	/* returns distances in da and point coords in pa */
	int xx, yy, zz, xi, yi, zi;

	xi = (int)floor(p[0]);
	yi = (int)floor(p[1]);
	zi = (int)floor(p[2]);

	da[0] = 1e10;
	da[1] = 1e10;
	da[2] = 1e10;
	da[3] = 1e10;

	for (xx = xi - 1; xx <= xi + 1; xx++) {
		for (yy = yi - 1; yy <= yi + 1; yy++) {
			for (zz = zi - 1; zz <= zi + 1; zz++) {
				point ip = point(xx, yy, zz);
				point vp = (point)cellnoise_color(ip);
				point cc = (vp + ip);
				point pd = p - cc;
				float d = 1.0;
				if(length(cc*mask_scale-mask_center*mask_scale) < mask_dist){
					d = voronoi_distance(distance_metric, pd, e);
				}
				vp += point(xx, yy, zz);
				if (d < da[0]) {
					da[3] = da[2];
					da[2] = da[1];
					da[1] = da[0];
					da[0] = d;

					pa[3] = pa[2];
					pa[2] = pa[1];
					pa[1] = pa[0];
					pa[0] = vp;
				}
				else if (d < da[1]) {
					da[3] = da[2];
					da[2] = da[1];
					da[1] = d;

					pa[3] = pa[2];
					pa[2] = pa[1];
					pa[1] = vp;
				}
				else if (d < da[2]) {
					da[3] = da[2];
					da[2] = d;

					pa[3] = pa[2];
					pa[2] = vp;
				}
				else if (d < da[3]) {
					da[3] = d;
					pa[3] = vp;
				}
			}
		}
	}
	if(distance_metric <= 5){
		da[0] = fmod(da[0], e);
	}
}

shader VoronoiAll(
	point pos_in = P,
	float scale = 1,
	point mask_center = point(0,0,0),
	point mask_scale = point(1,1,1),
	float mask_dist = 999,
	int metric = 0,
	float metric_mod = 999,
	output float Fac1 = 0,
	output float Fac2 = 0,
	output float Fac3 = 0,
	output float Fac4 = 0
){
	float da[4];
	point pa[4];

	//string distance_metric;
	//if (Metric == 0) distance_metric = "Distance Squared";
	//if (Metric == 1) distance_metric = "Actual Distance";
	//if (Metric == 2) distance_metric = "Manhattan";
	//if (Metric == 3) distance_metric = "Chebychev";
	//if (Metric == 4) distance_metric = "Minkovsky 1/2";
	//if (Metric == 5) distance_metric = "Minkovsky 4";
	//if (Metric == 6) distance_metric = "Minkovsky";
	//if (Metric == 7) distance_metric = "Sine";
	voronoi(pos_in*scale, metric, metric_mod, da, pa, mask_center*scale, mask_dist*scale, mask_scale);
	Fac1 = da[0];
	Fac2 = da[1];
	Fac3 = da[2];
	Fac4 = da[3];
}
